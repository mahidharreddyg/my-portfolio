"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/DecryptedText/DecryptedText.tsx":
/*!********************************************************!*\
  !*** ./src/components/DecryptedText/DecryptedText.tsx ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DecryptedText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/.pnpm/framer-motion@12.18.1_@emotion+is-prop-valid@1.3.1_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n\nvar _s = $RefreshSig$();\n\n\nfunction DecryptedText(param) {\n    let { text, speed = 50, maxIterations = 10, sequential = false, revealDirection = \"start\", useOriginalCharsOnly = false, characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+\", className = \"\", parentClassName = \"\", encryptedClassName = \"\", animateOn = \"hover\", ...props } = param;\n    _s();\n    const [displayText, setDisplayText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(text);\n    const [isHovering, setIsHovering] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isScrambling, setIsScrambling] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [revealedIndices, setRevealedIndices] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    const [hasAnimated, setHasAnimated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Auto-trigger animation when text changes or component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DecryptedText.useEffect\": ()=>{\n            if (animateOn === \"auto\") {\n                // Reset all states\n                setHasAnimated(false);\n                setRevealedIndices(new Set());\n                setIsScrambling(false);\n                setDisplayText(text);\n                // Start animation immediately\n                setIsHovering(true);\n                // Calculate animation duration and reset\n                const duration = sequential ? text.length * speed : maxIterations * speed;\n                const resetTimer = setTimeout({\n                    \"DecryptedText.useEffect.resetTimer\": ()=>{\n                        setIsHovering(false);\n                        setHasAnimated(true);\n                    }\n                }[\"DecryptedText.useEffect.resetTimer\"], duration + 500);\n                return ({\n                    \"DecryptedText.useEffect\": ()=>clearTimeout(resetTimer)\n                })[\"DecryptedText.useEffect\"];\n            }\n        }\n    }[\"DecryptedText.useEffect\"], [\n        text,\n        animateOn,\n        sequential,\n        speed,\n        maxIterations\n    ]);\n    // Force immediate animation on mount for auto mode\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DecryptedText.useEffect\": ()=>{\n            if (animateOn === \"auto\" && !hasAnimated) {\n                const mountTimer = setTimeout({\n                    \"DecryptedText.useEffect.mountTimer\": ()=>{\n                        setIsHovering(true);\n                    }\n                }[\"DecryptedText.useEffect.mountTimer\"], 100);\n                return ({\n                    \"DecryptedText.useEffect\": ()=>clearTimeout(mountTimer)\n                })[\"DecryptedText.useEffect\"];\n            }\n        }\n    }[\"DecryptedText.useEffect\"], [\n        animateOn,\n        hasAnimated\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DecryptedText.useEffect\": ()=>{\n            let interval;\n            let currentIteration = 0;\n            const getNextIndex = {\n                \"DecryptedText.useEffect.getNextIndex\": (revealedSet)=>{\n                    const textLength = text.length;\n                    switch(revealDirection){\n                        case \"start\":\n                            return revealedSet.size;\n                        case \"end\":\n                            return textLength - 1 - revealedSet.size;\n                        case \"center\":\n                            {\n                                const middle = Math.floor(textLength / 2);\n                                const offset = Math.floor(revealedSet.size / 2);\n                                const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\n                                if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\n                                    return nextIndex;\n                                }\n                                for(let i = 0; i < textLength; i++){\n                                    if (!revealedSet.has(i)) return i;\n                                }\n                                return 0;\n                            }\n                        default:\n                            return revealedSet.size;\n                    }\n                }\n            }[\"DecryptedText.useEffect.getNextIndex\"];\n            const availableChars = useOriginalCharsOnly ? Array.from(new Set(text.split(\"\"))).filter({\n                \"DecryptedText.useEffect\": (char)=>char !== \" \"\n            }[\"DecryptedText.useEffect\"]) : characters.split(\"\");\n            const shuffleText = {\n                \"DecryptedText.useEffect.shuffleText\": (originalText, currentRevealed)=>{\n                    if (useOriginalCharsOnly) {\n                        const positions = originalText.split(\"\").map({\n                            \"DecryptedText.useEffect.shuffleText.positions\": (char, i)=>({\n                                    char,\n                                    isSpace: char === \" \",\n                                    index: i,\n                                    isRevealed: currentRevealed.has(i)\n                                })\n                        }[\"DecryptedText.useEffect.shuffleText.positions\"]);\n                        const nonSpaceChars = positions.filter({\n                            \"DecryptedText.useEffect.shuffleText.nonSpaceChars\": (p)=>!p.isSpace && !p.isRevealed\n                        }[\"DecryptedText.useEffect.shuffleText.nonSpaceChars\"]).map({\n                            \"DecryptedText.useEffect.shuffleText.nonSpaceChars\": (p)=>p.char\n                        }[\"DecryptedText.useEffect.shuffleText.nonSpaceChars\"]);\n                        for(let i = nonSpaceChars.length - 1; i > 0; i--){\n                            const j = Math.floor(Math.random() * (i + 1));\n                            [nonSpaceChars[i], nonSpaceChars[j]] = [\n                                nonSpaceChars[j],\n                                nonSpaceChars[i]\n                            ];\n                        }\n                        let charIndex = 0;\n                        return positions.map({\n                            \"DecryptedText.useEffect.shuffleText\": (p)=>{\n                                if (p.isSpace) return \" \";\n                                if (p.isRevealed) return originalText[p.index];\n                                return nonSpaceChars[charIndex++];\n                            }\n                        }[\"DecryptedText.useEffect.shuffleText\"]).join(\"\");\n                    } else {\n                        return originalText.split(\"\").map({\n                            \"DecryptedText.useEffect.shuffleText\": (char, i)=>{\n                                if (char === \" \") return \" \";\n                                if (currentRevealed.has(i)) return originalText[i];\n                                return availableChars[Math.floor(Math.random() * availableChars.length)];\n                            }\n                        }[\"DecryptedText.useEffect.shuffleText\"]).join(\"\");\n                    }\n                }\n            }[\"DecryptedText.useEffect.shuffleText\"];\n            if (isHovering) {\n                setIsScrambling(true);\n                interval = setInterval({\n                    \"DecryptedText.useEffect\": ()=>{\n                        setRevealedIndices({\n                            \"DecryptedText.useEffect\": (prevRevealed)=>{\n                                if (sequential) {\n                                    if (prevRevealed.size < text.length) {\n                                        const nextIndex = getNextIndex(prevRevealed);\n                                        const newRevealed = new Set(prevRevealed);\n                                        newRevealed.add(nextIndex);\n                                        setDisplayText(shuffleText(text, newRevealed));\n                                        return newRevealed;\n                                    } else {\n                                        clearInterval(interval);\n                                        setIsScrambling(false);\n                                        return prevRevealed;\n                                    }\n                                } else {\n                                    setDisplayText(shuffleText(text, prevRevealed));\n                                    currentIteration++;\n                                    if (currentIteration >= maxIterations) {\n                                        clearInterval(interval);\n                                        setIsScrambling(false);\n                                        setDisplayText(text);\n                                    }\n                                    return prevRevealed;\n                                }\n                            }\n                        }[\"DecryptedText.useEffect\"]);\n                    }\n                }[\"DecryptedText.useEffect\"], speed);\n            } else {\n                if (animateOn !== \"auto\") {\n                    setDisplayText(text);\n                    setRevealedIndices(new Set());\n                    setIsScrambling(false);\n                }\n            }\n            return ({\n                \"DecryptedText.useEffect\": ()=>{\n                    if (interval) clearInterval(interval);\n                }\n            })[\"DecryptedText.useEffect\"];\n        }\n    }[\"DecryptedText.useEffect\"], [\n        isHovering,\n        text,\n        speed,\n        maxIterations,\n        sequential,\n        revealDirection,\n        characters,\n        useOriginalCharsOnly,\n        animateOn\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DecryptedText.useEffect\": ()=>{\n            if (animateOn !== \"view\") return;\n            const observerCallback = {\n                \"DecryptedText.useEffect.observerCallback\": (entries)=>{\n                    entries.forEach({\n                        \"DecryptedText.useEffect.observerCallback\": (entry)=>{\n                            if (entry.isIntersecting && !hasAnimated) {\n                                setIsHovering(true);\n                                setHasAnimated(true);\n                            }\n                        }\n                    }[\"DecryptedText.useEffect.observerCallback\"]);\n                }\n            }[\"DecryptedText.useEffect.observerCallback\"];\n            const observerOptions = {\n                root: null,\n                rootMargin: \"0px\",\n                threshold: 0.1\n            };\n            const observer = new IntersectionObserver(observerCallback, observerOptions);\n            const currentRef = containerRef.current;\n            if (currentRef) {\n                observer.observe(currentRef);\n            }\n            return ({\n                \"DecryptedText.useEffect\": ()=>{\n                    if (currentRef) observer.unobserve(currentRef);\n                }\n            })[\"DecryptedText.useEffect\"];\n        }\n    }[\"DecryptedText.useEffect\"], [\n        animateOn,\n        hasAnimated\n    ]);\n    const hoverProps = animateOn === \"hover\" ? {\n        onMouseEnter: ()=>setIsHovering(true),\n        onMouseLeave: ()=>setIsHovering(false)\n    } : {};\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.span, {\n        ref: containerRef,\n        className: \"inline-block whitespace-pre-wrap \".concat(parentClassName),\n        ...hoverProps,\n        ...props,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"sr-only\",\n                children: displayText\n            }, void 0, false, {\n                fileName: \"/Users/mahidharreddyg/Mahi/My Projects/Web Dev/my-portfolio/src/components/DecryptedText/DecryptedText.tsx\",\n                lineNumber: 255,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                \"aria-hidden\": \"true\",\n                children: displayText.split(\"\").map((char, index)=>{\n                    const isRevealedOrDone = revealedIndices.has(index) || !isScrambling || !isHovering;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: isRevealedOrDone ? className : encryptedClassName,\n                        children: char\n                    }, index, false, {\n                        fileName: \"/Users/mahidharreddyg/Mahi/My Projects/Web Dev/my-portfolio/src/components/DecryptedText/DecryptedText.tsx\",\n                        lineNumber: 263,\n                        columnNumber: 13\n                    }, this);\n                })\n            }, void 0, false, {\n                fileName: \"/Users/mahidharreddyg/Mahi/My Projects/Web Dev/my-portfolio/src/components/DecryptedText/DecryptedText.tsx\",\n                lineNumber: 257,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/mahidharreddyg/Mahi/My Projects/Web Dev/my-portfolio/src/components/DecryptedText/DecryptedText.tsx\",\n        lineNumber: 249,\n        columnNumber: 5\n    }, this);\n}\n_s(DecryptedText, \"KrMlz+Znz3/aEFOihMchmgMeF2c=\");\n_c = DecryptedText;\nvar _c;\n$RefreshReg$(_c, \"DecryptedText\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0RlY3J5cHRlZFRleHQvRGVjcnlwdGVkVGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvRDtBQUNJO0FBZ0J6QyxTQUFTSSxjQUFjLEtBYWpCO1FBYmlCLEVBQ3BDQyxJQUFJLEVBQ0pDLFFBQVEsRUFBRSxFQUNWQyxnQkFBZ0IsRUFBRSxFQUNsQkMsYUFBYSxLQUFLLEVBQ2xCQyxrQkFBa0IsT0FBTyxFQUN6QkMsdUJBQXVCLEtBQUssRUFDNUJDLGFBQWEsa0VBQWtFLEVBQy9FQyxZQUFZLEVBQUUsRUFDZEMsa0JBQWtCLEVBQUUsRUFDcEJDLHFCQUFxQixFQUFFLEVBQ3ZCQyxZQUFZLE9BQU8sRUFDbkIsR0FBR0MsT0FDZ0IsR0FiaUI7O0lBY3BDLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHakIsK0NBQVFBLENBQVNJO0lBQ3ZELE1BQU0sQ0FBQ2MsWUFBWUMsY0FBYyxHQUFHbkIsK0NBQVFBLENBQVU7SUFDdEQsTUFBTSxDQUFDb0IsY0FBY0MsZ0JBQWdCLEdBQUdyQiwrQ0FBUUEsQ0FBVTtJQUMxRCxNQUFNLENBQUNzQixpQkFBaUJDLG1CQUFtQixHQUFHdkIsK0NBQVFBLENBQWMsSUFBSXdCO0lBQ3hFLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHMUIsK0NBQVFBLENBQVU7SUFDeEQsTUFBTTJCLGVBQWUxQiw2Q0FBTUEsQ0FBa0I7SUFFN0MsK0RBQStEO0lBQy9ERixnREFBU0E7bUNBQUM7WUFDUixJQUFJZSxjQUFjLFFBQVE7Z0JBQ3hCLG1CQUFtQjtnQkFDbkJZLGVBQWU7Z0JBQ2ZILG1CQUFtQixJQUFJQztnQkFDdkJILGdCQUFnQjtnQkFDaEJKLGVBQWViO2dCQUVmLDhCQUE4QjtnQkFDOUJlLGNBQWM7Z0JBRWQseUNBQXlDO2dCQUN6QyxNQUFNUyxXQUFXckIsYUFBYUgsS0FBS3lCLE1BQU0sR0FBR3hCLFFBQVFDLGdCQUFnQkQ7Z0JBQ3BFLE1BQU15QixhQUFh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LE1BQU1rQyxtQkFDSnZFLGdCQUFnQnVCLEdBQUcsQ0FBQ2MsVUFBVSxDQUFDdkMsZ0JBQWdCLENBQUNGO29CQUVsRCxxQkFDRSw4REFBQ3dFO3dCQUVDL0UsV0FBV2tGLG1CQUFtQmxGLFlBQVlFO2tDQUV6Q3VDO3VCQUhJTzs7Ozs7Z0JBTVg7Ozs7Ozs7Ozs7OztBQUlSO0dBaFF3QnhEO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvbWFoaWRoYXJyZWRkeWcvTWFoaS9NeSBQcm9qZWN0cy9XZWIgRGV2L215LXBvcnRmb2xpby9zcmMvY29tcG9uZW50cy9EZWNyeXB0ZWRUZXh0L0RlY3J5cHRlZFRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uLCBIVE1MTW90aW9uUHJvcHMgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiO1xuXG5pbnRlcmZhY2UgRGVjcnlwdGVkVGV4dFByb3BzIGV4dGVuZHMgSFRNTE1vdGlvblByb3BzPFwic3BhblwiPiB7XG4gIHRleHQ6IHN0cmluZztcbiAgc3BlZWQ/OiBudW1iZXI7XG4gIG1heEl0ZXJhdGlvbnM/OiBudW1iZXI7XG4gIHNlcXVlbnRpYWw/OiBib29sZWFuO1xuICByZXZlYWxEaXJlY3Rpb24/OiBcInN0YXJ0XCIgfCBcImVuZFwiIHwgXCJjZW50ZXJcIjtcbiAgdXNlT3JpZ2luYWxDaGFyc09ubHk/OiBib29sZWFuO1xuICBjaGFyYWN0ZXJzPzogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGVuY3J5cHRlZENsYXNzTmFtZT86IHN0cmluZztcbiAgcGFyZW50Q2xhc3NOYW1lPzogc3RyaW5nO1xuICBhbmltYXRlT24/OiBcInZpZXdcIiB8IFwiaG92ZXJcIiB8IFwiYXV0b1wiO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWNyeXB0ZWRUZXh0KHtcbiAgdGV4dCxcbiAgc3BlZWQgPSA1MCxcbiAgbWF4SXRlcmF0aW9ucyA9IDEwLFxuICBzZXF1ZW50aWFsID0gZmFsc2UsXG4gIHJldmVhbERpcmVjdGlvbiA9IFwic3RhcnRcIixcbiAgdXNlT3JpZ2luYWxDaGFyc09ubHkgPSBmYWxzZSxcbiAgY2hhcmFjdGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiFAIyQlXiYqKClfK1wiLFxuICBjbGFzc05hbWUgPSBcIlwiLFxuICBwYXJlbnRDbGFzc05hbWUgPSBcIlwiLFxuICBlbmNyeXB0ZWRDbGFzc05hbWUgPSBcIlwiLFxuICBhbmltYXRlT24gPSBcImhvdmVyXCIsXG4gIC4uLnByb3BzXG59OiBEZWNyeXB0ZWRUZXh0UHJvcHMpIHtcbiAgY29uc3QgW2Rpc3BsYXlUZXh0LCBzZXREaXNwbGF5VGV4dF0gPSB1c2VTdGF0ZTxzdHJpbmc+KHRleHQpO1xuICBjb25zdCBbaXNIb3ZlcmluZywgc2V0SXNIb3ZlcmluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtpc1NjcmFtYmxpbmcsIHNldElzU2NyYW1ibGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtyZXZlYWxlZEluZGljZXMsIHNldFJldmVhbGVkSW5kaWNlc10gPSB1c2VTdGF0ZTxTZXQ8bnVtYmVyPj4obmV3IFNldCgpKTtcbiAgY29uc3QgW2hhc0FuaW1hdGVkLCBzZXRIYXNBbmltYXRlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MU3BhbkVsZW1lbnQ+KG51bGwpO1xuXG4gIC8vIEF1dG8tdHJpZ2dlciBhbmltYXRpb24gd2hlbiB0ZXh0IGNoYW5nZXMgb3IgY29tcG9uZW50IG1vdW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhbmltYXRlT24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAvLyBSZXNldCBhbGwgc3RhdGVzXG4gICAgICBzZXRIYXNBbmltYXRlZChmYWxzZSk7XG4gICAgICBzZXRSZXZlYWxlZEluZGljZXMobmV3IFNldCgpKTtcbiAgICAgIHNldElzU2NyYW1ibGluZyhmYWxzZSk7XG4gICAgICBzZXREaXNwbGF5VGV4dCh0ZXh0KTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBzZXRJc0hvdmVyaW5nKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgYW5pbWF0aW9uIGR1cmF0aW9uIGFuZCByZXNldFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBzZXF1ZW50aWFsID8gdGV4dC5sZW5ndGggKiBzcGVlZCA6IG1heEl0ZXJhdGlvbnMgKiBzcGVlZDtcbiAgICAgIGNvbnN0IHJlc2V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0SXNIb3ZlcmluZyhmYWxzZSk7XG4gICAgICAgIHNldEhhc0FuaW1hdGVkKHRydWUpO1xuICAgICAgfSwgZHVyYXRpb24gKyA1MDApO1xuICAgICAgXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHJlc2V0VGltZXIpO1xuICAgIH1cbiAgfSwgW3RleHQsIGFuaW1hdGVPbiwgc2VxdWVudGlhbCwgc3BlZWQsIG1heEl0ZXJhdGlvbnNdKTtcblxuICAvLyBGb3JjZSBpbW1lZGlhdGUgYW5pbWF0aW9uIG9uIG1vdW50IGZvciBhdXRvIG1vZGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYW5pbWF0ZU9uID09PSBcImF1dG9cIiAmJiAhaGFzQW5pbWF0ZWQpIHtcbiAgICAgIGNvbnN0IG1vdW50VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0SXNIb3ZlcmluZyh0cnVlKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgICBcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQobW91bnRUaW1lcik7XG4gICAgfVxuICB9LCBbYW5pbWF0ZU9uLCBoYXNBbmltYXRlZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVydmFsOiBOb2RlSlMuVGltZW91dDtcbiAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IDA7XG5cbiAgICBjb25zdCBnZXROZXh0SW5kZXggPSAocmV2ZWFsZWRTZXQ6IFNldDxudW1iZXI+KTogbnVtYmVyID0+IHtcbiAgICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHN3aXRjaCAocmV2ZWFsRGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgIHJldHVybiByZXZlYWxlZFNldC5zaXplO1xuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIHRleHRMZW5ndGggLSAxIC0gcmV2ZWFsZWRTZXQuc2l6ZTtcbiAgICAgICAgY2FzZSBcImNlbnRlclwiOiB7XG4gICAgICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcih0ZXh0TGVuZ3RoIC8gMik7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcihyZXZlYWxlZFNldC5zaXplIC8gMik7XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID1cbiAgICAgICAgICAgIHJldmVhbGVkU2V0LnNpemUgJSAyID09PSAwID8gbWlkZGxlICsgb2Zmc2V0IDogbWlkZGxlIC0gb2Zmc2V0IC0gMTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5leHRJbmRleCA+PSAwICYmXG4gICAgICAgICAgICBuZXh0SW5kZXggPCB0ZXh0TGVuZ3RoICYmXG4gICAgICAgICAgICAhcmV2ZWFsZWRTZXQuaGFzKG5leHRJbmRleClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXJldmVhbGVkU2V0LmhhcyhpKSkgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHJldmVhbGVkU2V0LnNpemU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGF2YWlsYWJsZUNoYXJzID0gdXNlT3JpZ2luYWxDaGFyc09ubHlcbiAgICAgID8gQXJyYXkuZnJvbShuZXcgU2V0KHRleHQuc3BsaXQoXCJcIikpKS5maWx0ZXIoKGNoYXIpID0+IGNoYXIgIT09IFwiIFwiKVxuICAgICAgOiBjaGFyYWN0ZXJzLnNwbGl0KFwiXCIpO1xuXG4gICAgY29uc3Qgc2h1ZmZsZVRleHQgPSAoXG4gICAgICBvcmlnaW5hbFRleHQ6IHN0cmluZyxcbiAgICAgIGN1cnJlbnRSZXZlYWxlZDogU2V0PG51bWJlcj4sXG4gICAgKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICh1c2VPcmlnaW5hbENoYXJzT25seSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBvcmlnaW5hbFRleHQuc3BsaXQoXCJcIikubWFwKChjaGFyLCBpKSA9PiAoe1xuICAgICAgICAgIGNoYXIsXG4gICAgICAgICAgaXNTcGFjZTogY2hhciA9PT0gXCIgXCIsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgaXNSZXZlYWxlZDogY3VycmVudFJldmVhbGVkLmhhcyhpKSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IG5vblNwYWNlQ2hhcnMgPSBwb3NpdGlvbnNcbiAgICAgICAgICAuZmlsdGVyKChwKSA9PiAhcC5pc1NwYWNlICYmICFwLmlzUmV2ZWFsZWQpXG4gICAgICAgICAgLm1hcCgocCkgPT4gcC5jaGFyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbm9uU3BhY2VDaGFycy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgIFtub25TcGFjZUNoYXJzW2ldLCBub25TcGFjZUNoYXJzW2pdXSA9IFtcbiAgICAgICAgICAgIG5vblNwYWNlQ2hhcnNbal0sXG4gICAgICAgICAgICBub25TcGFjZUNoYXJzW2ldLFxuICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uc1xuICAgICAgICAgIC5tYXAoKHApID0+IHtcbiAgICAgICAgICAgIGlmIChwLmlzU3BhY2UpIHJldHVybiBcIiBcIjtcbiAgICAgICAgICAgIGlmIChwLmlzUmV2ZWFsZWQpIHJldHVybiBvcmlnaW5hbFRleHRbcC5pbmRleF07XG4gICAgICAgICAgICByZXR1cm4gbm9uU3BhY2VDaGFyc1tjaGFySW5kZXgrK107XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFRleHRcbiAgICAgICAgICAuc3BsaXQoXCJcIilcbiAgICAgICAgICAubWFwKChjaGFyLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gXCIgXCIpIHJldHVybiBcIiBcIjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmV2ZWFsZWQuaGFzKGkpKSByZXR1cm4gb3JpZ2luYWxUZXh0W2ldO1xuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZUNoYXJzW1xuICAgICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhdmFpbGFibGVDaGFycy5sZW5ndGgpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChpc0hvdmVyaW5nKSB7XG4gICAgICBzZXRJc1NjcmFtYmxpbmcodHJ1ZSk7XG4gICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgc2V0UmV2ZWFsZWRJbmRpY2VzKChwcmV2UmV2ZWFsZWQpID0+IHtcbiAgICAgICAgICBpZiAoc2VxdWVudGlhbCkge1xuICAgICAgICAgICAgaWYgKHByZXZSZXZlYWxlZC5zaXplIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gZ2V0TmV4dEluZGV4KHByZXZSZXZlYWxlZCk7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1JldmVhbGVkID0gbmV3IFNldChwcmV2UmV2ZWFsZWQpO1xuICAgICAgICAgICAgICBuZXdSZXZlYWxlZC5hZGQobmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgc2V0RGlzcGxheVRleHQoc2h1ZmZsZVRleHQodGV4dCwgbmV3UmV2ZWFsZWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1JldmVhbGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgIHNldElzU2NyYW1ibGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2UmV2ZWFsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldERpc3BsYXlUZXh0KHNodWZmbGVUZXh0KHRleHQsIHByZXZSZXZlYWxlZCkpO1xuICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVyYXRpb24gPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgc2V0SXNTY3JhbWJsaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgc2V0RGlzcGxheVRleHQodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldlJldmVhbGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBzcGVlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbmltYXRlT24gIT09IFwiYXV0b1wiKSB7XG4gICAgICAgIHNldERpc3BsYXlUZXh0KHRleHQpO1xuICAgICAgICBzZXRSZXZlYWxlZEluZGljZXMobmV3IFNldCgpKTtcbiAgICAgICAgc2V0SXNTY3JhbWJsaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGludGVydmFsKSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbXG4gICAgaXNIb3ZlcmluZyxcbiAgICB0ZXh0LFxuICAgIHNwZWVkLFxuICAgIG1heEl0ZXJhdGlvbnMsXG4gICAgc2VxdWVudGlhbCxcbiAgICByZXZlYWxEaXJlY3Rpb24sXG4gICAgY2hhcmFjdGVycyxcbiAgICB1c2VPcmlnaW5hbENoYXJzT25seSxcbiAgICBhbmltYXRlT24sXG4gIF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFuaW1hdGVPbiAhPT0gXCJ2aWV3XCIpIHJldHVybjtcblxuICAgIGNvbnN0IG9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeVtdKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyAmJiAhaGFzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBzZXRJc0hvdmVyaW5nKHRydWUpO1xuICAgICAgICAgIHNldEhhc0FuaW1hdGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIHJvb3RNYXJnaW46IFwiMHB4XCIsXG4gICAgICB0aHJlc2hvbGQ6IDAuMSxcbiAgICB9O1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICBvYnNlcnZlckNhbGxiYWNrLFxuICAgICAgb2JzZXJ2ZXJPcHRpb25zLFxuICAgICk7XG4gICAgY29uc3QgY3VycmVudFJlZiA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50UmVmKSB7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRSZWYpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudFJlZikgb2JzZXJ2ZXIudW5vYnNlcnZlKGN1cnJlbnRSZWYpO1xuICAgIH07XG4gIH0sIFthbmltYXRlT24sIGhhc0FuaW1hdGVkXSk7XG5cbiAgY29uc3QgaG92ZXJQcm9wcyA9XG4gICAgYW5pbWF0ZU9uID09PSBcImhvdmVyXCJcbiAgICAgID8ge1xuICAgICAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gc2V0SXNIb3ZlcmluZyh0cnVlKSxcbiAgICAgICAgICBvbk1vdXNlTGVhdmU6ICgpID0+IHNldElzSG92ZXJpbmcoZmFsc2UpLFxuICAgICAgICB9XG4gICAgICA6IHt9O1xuXG4gIHJldHVybiAoXG4gICAgPG1vdGlvbi5zcGFuXG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgIGNsYXNzTmFtZT17YGlubGluZS1ibG9jayB3aGl0ZXNwYWNlLXByZS13cmFwICR7cGFyZW50Q2xhc3NOYW1lfWB9XG4gICAgICB7Li4uaG92ZXJQcm9wc31cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+e2Rpc3BsYXlUZXh0fTwvc3Bhbj5cblxuICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgIHtkaXNwbGF5VGV4dC5zcGxpdChcIlwiKS5tYXAoKGNoYXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNSZXZlYWxlZE9yRG9uZSA9XG4gICAgICAgICAgICByZXZlYWxlZEluZGljZXMuaGFzKGluZGV4KSB8fCAhaXNTY3JhbWJsaW5nIHx8ICFpc0hvdmVyaW5nO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17aXNSZXZlYWxlZE9yRG9uZSA/IGNsYXNzTmFtZSA6IGVuY3J5cHRlZENsYXNzTmFtZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge2NoYXJ9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3NwYW4+XG4gICAgPC9tb3Rpb24uc3Bhbj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsIm1vdGlvbiIsIkRlY3J5cHRlZFRleHQiLCJ0ZXh0Iiwic3BlZWQiLCJtYXhJdGVyYXRpb25zIiwic2VxdWVudGlhbCIsInJldmVhbERpcmVjdGlvbiIsInVzZU9yaWdpbmFsQ2hhcnNPbmx5IiwiY2hhcmFjdGVycyIsImNsYXNzTmFtZSIsInBhcmVudENsYXNzTmFtZSIsImVuY3J5cHRlZENsYXNzTmFtZSIsImFuaW1hdGVPbiIsInByb3BzIiwiZGlzcGxheVRleHQiLCJzZXREaXNwbGF5VGV4dCIsImlzSG92ZXJpbmciLCJzZXRJc0hvdmVyaW5nIiwiaXNTY3JhbWJsaW5nIiwic2V0SXNTY3JhbWJsaW5nIiwicmV2ZWFsZWRJbmRpY2VzIiwic2V0UmV2ZWFsZWRJbmRpY2VzIiwiU2V0IiwiaGFzQW5pbWF0ZWQiLCJzZXRIYXNBbmltYXRlZCIsImNvbnRhaW5lclJlZiIsImR1cmF0aW9uIiwibGVuZ3RoIiwicmVzZXRUaW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJtb3VudFRpbWVyIiwiaW50ZXJ2YWwiLCJjdXJyZW50SXRlcmF0aW9uIiwiZ2V0TmV4dEluZGV4IiwicmV2ZWFsZWRTZXQiLCJ0ZXh0TGVuZ3RoIiwic2l6ZSIsIm1pZGRsZSIsIk1hdGgiLCJmbG9vciIsIm9mZnNldCIsIm5leHRJbmRleCIsImhhcyIsImkiLCJhdmFpbGFibGVDaGFycyIsIkFycmF5IiwiZnJvbSIsInNwbGl0IiwiZmlsdGVyIiwiY2hhciIsInNodWZmbGVUZXh0Iiwib3JpZ2luYWxUZXh0IiwiY3VycmVudFJldmVhbGVkIiwicG9zaXRpb25zIiwibWFwIiwiaXNTcGFjZSIsImluZGV4IiwiaXNSZXZlYWxlZCIsIm5vblNwYWNlQ2hhcnMiLCJwIiwiaiIsInJhbmRvbSIsImNoYXJJbmRleCIsImpvaW4iLCJzZXRJbnRlcnZhbCIsInByZXZSZXZlYWxlZCIsIm5ld1JldmVhbGVkIiwiYWRkIiwiY2xlYXJJbnRlcnZhbCIsIm9ic2VydmVyQ2FsbGJhY2siLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJvYnNlcnZlck9wdGlvbnMiLCJyb290Iiwicm9vdE1hcmdpbiIsInRocmVzaG9sZCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJjdXJyZW50UmVmIiwiY3VycmVudCIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJob3ZlclByb3BzIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwic3BhbiIsInJlZiIsImFyaWEtaGlkZGVuIiwiaXNSZXZlYWxlZE9yRG9uZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/DecryptedText/DecryptedText.tsx\n"));

/***/ })

});